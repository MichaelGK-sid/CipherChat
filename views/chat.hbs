<div class="chat-container">
  <div class="chat-header">
    <div class="chat-contact-info">
      <div class="contact-avatar"></div>
      <span class="chat-contact-name">{{username}}</span>
    </div>
    <a href="/home" class="home-link">Home</a>
  </div>
  <div class="chat-messages" id="messages">
    {{#each messages}}
    <div class="message {{#if this.isMine}}message-mine{{else}}message-theirs{{/if}}">
      <div class="message-bubble" data-ciphertext="{{this.text}}" data-iv="{{this.iv}}">
        [Encrypted]
      </div>
    </div>
    {{/each}}
  </div>

  <div class="chat-input-container">
    <form id="chat-form" class="chat-form">
      <input type="text" id="message-input" placeholder="Type a message..." class="chat-input" required />
      <button type="submit" class="send-button">Send</button>
    </form>
  </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script src="/js/crypto.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', async function() {
    const socket = io();
    const currentUserId = '{{currentUserId}}';
    const recipientId = '{{recipientId}}';
    const recipientUsername = '{{username}}';
    
    const cryptoHandler = new CryptoHandler();
    let sharedAESKey = null;
    
    console.log('Current User:', currentUserId);
    console.log('Recipient:', recipientId);
    
    await cryptoHandler.loadKeysFromLocalStorage(currentUserId);
    
    if (!cryptoHandler.keyPair) {
      alert('Your encryption keys are not set up. Please logout and login again.');
      return;
    }
    
    // Fetch recipient's public key and derive shared secret
    try {
      const response = await fetch(`/api/user/${recipientUsername}/public-key`);
      const data = await response.json();
      
      if (data.success) {
        const recipientPublicKey = await cryptoHandler.importPublicKey(data.publicKey);
        sharedAESKey = await cryptoHandler.deriveAESKey(cryptoHandler.keyPair.privateKey, recipientPublicKey);
        console.log('Shared encryption key derived successfully');
      } else {
        alert('Could not fetch recipient\'s public key');
        return;
      }
    } catch (error) {
      console.error('Error setting up encryption:', error);
      alert('Encryption setup failed');
      return;
    }

    // Decrypt existing messages
    const messageElements = document.querySelectorAll('.message-bubble');
    for (const msgEl of messageElements) {
      const ciphertext = msgEl.getAttribute('data-ciphertext');
      const iv = msgEl.getAttribute('data-iv');
      
      if (ciphertext && iv) {
        try {
          const decrypted = await cryptoHandler.decryptMessage(ciphertext, iv, sharedAESKey);
          msgEl.textContent = decrypted;
        } catch (error) {
          console.error('Decryption failed:', error);
          msgEl.textContent = '[Decryption failed]';
        }
      }
    }
    
    socket.emit('register_user', currentUserId);
    
    // Handle incoming messages
    socket.on('receive_message', async (data) => {
      console.log('Received message:', data);
      if (data.senderId === recipientId) {
        try {
          const decrypted = await cryptoHandler.decryptMessage(data.ciphertext, data.iv, sharedAESKey);
          addMessageToChat(decrypted, false);
        } catch (error) {
          console.error('Failed to decrypt incoming message:', error);
          addMessageToChat('[Decryption failed]', false);
        }
      }
    });
    

    socket.on('message_sent', (data) => {
      console.log('Message sent successfully:', data);
    });
    
    // Handle message sending
    const chatForm = document.getElementById('chat-form');
    if (chatForm) {
      chatForm.addEventListener('submit', async function(e) {
        e.preventDefault();
        await sendMessage();
      });
    }
    
    async function sendMessage() {
      const input = document.getElementById('message-input');
      const message = input.value.trim();
      
      if (message && sharedAESKey) {
        console.log('Encrypting and sending message:', message);
        
        try {
          const encrypted = await cryptoHandler.encryptMessage(message, sharedAESKey);
          
          socket.emit('send_message', {
            senderId: currentUserId,
            recipientId: recipientId,
            ciphertext: encrypted.ciphertext,
            iv: encrypted.iv
          });
          
          addMessageToChat(message, true);
          input.value = '';
        } catch (error) {
          console.error('Encryption failed:', error);
          alert('Failed to encrypt message');
        }
      }
    }
    
    function addMessageToChat(text, isMine) {
      const messagesContainer = document.getElementById('messages');
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message ' + (isMine ? 'message-mine' : 'message-theirs');
      
      const bubbleDiv = document.createElement('div');
      bubbleDiv.className = 'message-bubble';
      bubbleDiv.textContent = text;
      
      messageDiv.appendChild(bubbleDiv);
      messagesContainer.appendChild(messageDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
    }
  });
</script>